# 基于规则的优化

>查询重写:把执行起来十分耗费性能的语句转换成某种可以比较高效执行的形式。  
派生表：跟在`from`关键词后面的子查询

## 条件从简

- 移除不必要的括号

```sql
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
简化为
(a = 5 and b = c) OR (a > c AND c < 5)
```

- 常量传递

```sql
a = 5 AND b > a
简化为
a = 5 AND b > 5
```

- 等值传递

```sql
a = b and b = c and c = 5
简化为
a = 5 and b = 5 and c = 5
```

- 移除没用的条件

```sql
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
简化为
a < 1 OR a = 6
```

- 表达式计算：**最好让索引列以单独的形式出现在表达式中**

```sql
a = 5 + 1
简化为
a = 6
```

- HAVING子句和WHERE子句的合并：如果查询语句中没有出现诸如SUM、MAX等等的聚集函数以及GROUP BY子句，优化器就把HAVING子句和WHERE子句合并起来。

- 常量表检测

## 外连接消除

>在外连接查询中，指定的WHERE子句中包含被驱动表中的列不为NULL值的条件称之为空值拒绝（英文名：reject-NULL）。  
**在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。**

## 子查询优化

### 返回的结果集区分子查询：

- `标量子查询`：那些只返回一个单一值的子查询

  ```sql
  SELECT (SELECT m1 FROM t1 LIMIT 1);
  ```

- `行子查询`：返回一条包含多个列的记录的子查询
- `列子查询`：结果集包含多条记录，但是只有一列的数据
- `表子查询`：结果集包含很多条记录，又包含很多个列

### 按与外层查询关系来区分子查询

- 不相关子查询：子查询可以单独运行出结果，而不依赖于外层查询的值
- 相关子查询：子查询的执行需要依赖于外层查询的值

    ```sql
    # n1是表t1的列，也就是外层查询的列
    SELECT * FROM t1 WHERE m1 IN `(SELECT m2 FROM t2 WHERE n1 = n2)`;
    ```

### 子查询在布尔表达式中的使用

- 使用=、>、<、>=、<=、<>、!=、<=>作为布尔表达式的操作符
  
    ```sql
    SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
    ```

- [NOT] IN/ANY/SOME/ALL子查询

    ```sql
    SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
    ```

- EXISTS子查询:仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是什么

    ```sql
    SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);
    ```

### 子查询语法注意事项

- 子查询必须用小括号扩起来。
- 在`SELECT`子句中的子查询必须是标量子查询。
- 在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用`LIMIT 1`语句来限制记录数量
- 对于`[NOT] IN/ANY/SOME/ALL`子查询来说，子查询中不允许有`L`IMIT`语句。
- 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询

    ```sql
    DELETE FROM t1 WHERE m1 < (SELECT MAX(m1) FROM t1);
    ```

### 子查询在MySQL中是怎么执行的

#### 标量子查询、行子查询的执行方式

- 不相关子查询：MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询
- 相关子查询：从外层获取相关条件、根据该条件执行子查询、根据子查询的查询结果判断是否要丢掉外层查询

#### IN子查询优化

- 物化表转连接：先存储子查询结果集到临时表，这种表也叫`物化表`，基于内存的物化表有哈希索引，基于磁盘的有B+树索引。然后`将子查询转换为连接查询`
- 将子查询转换为semi-join：不进行物化操作直接把子查询转换为连接

>优先使用`semi-join`优化，如果不符合转换条件，则先将子查询`物化`之后再执行查询或者执行`IN to EXISTS`转换